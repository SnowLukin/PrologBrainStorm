/*
        1 Построить предикат vz_prost(+X,+Y), проверяющий числа на взаимную
        простоту. (любой числовой алгоритм с применением рекурсии вверх или вниз).

        2 Построить предикат max_list(+List), определяющий индекс элемента списка,
        имеющего максимальную сумму чисел, меньших элемента и взаимно-простых с
        ним. Для построения воспользоваться предикатом из предыдущей задачи.
        (Воспользоваться рекурсией вверх или вниз).

        3 Построить предикат comb(+List,K,-Sochet), записывающий в Sochet
        все возможные сочетания по K элементов. (Возможна формулировка
        для любого комбинаторного объекта, размещения, перестановки,
        подмножества, с размещениями или без).

        4 С помощью предиката из предыдущих задач построить предикат с
        одним обязательным аргументом – список, который выводит на экран
        все сочетания взаимно-простых пар чисел.

        5 Построить предикат, который выводит на экран все слова длины 6
        над алфавитом [a,b,c,d,e,f], в которых три буквы a, две буквы b.

        6 Граф задан списком вершин и списком ребер, где каждое ребро –
        список двух вершин. [a,b,c,d,e], [[a,b],[a,e],[b,c],[c,d],[d,e],[c,e],[a,c]].
        Зная, что таким образом задан ОРИЕНТИРОВАННЫЙ граф, найти
        эйлеров цикл. (или любые задачи на графы из лекции)
*/

% -------- 1 --------

gcd(0, Y, Y):- !.
gcd(X, 0, X):- !.
gcd(X, X, X):- !.
gcd(X, Y, Result):-
    Y > X,
    NewY is Y - X,
    gcd(X, NewY, Result), !.
gcd(X, Y, Result):-
    Y < X,
    NewY is X - Y,
    gcd(NewY, Y, Result), !.

areCoPrimes(X, Y):-
    gcd(X, Y, Result),
    Result is 1, true; false.


% -------- 2 --------

getSumOfDigits(X, Counter, Result):-
    X < 10,
    NewCounter is Counter + X,
    Result is NewCounter, !.
getSumOfDigits(X, Counter, Result):-
    Mod is X mod 10,
    Div is X div 10,
    NewCounter is Counter + Mod,
    getSumOfDigits(Div, NewCounter, Result).
getSumOfDigits(X, Result):- getSumOfDigits(X,0,Result).
